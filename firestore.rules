rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // ============================================

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // SECURITY: Super admin check using hardcoded emails (for bootstrapping)
    // Once custom claims are set, prefer using isAdmin() which checks token claims
    function isSuperAdmin() {
      return isAuthenticated() &&
             (request.auth.token.email == 'perriceconsulting@gmail.com' ||
              request.auth.token.email == 'weightlossprojectlab@gmail.com');
    }

    // SECURITY: Check admin status from Firebase Custom Claims (fast, no Firestore read)
    // Falls back to super admin check for bootstrapping
    function isAdmin() {
      return isAuthenticated() &&
             (isSuperAdmin() ||
              request.auth.token.admin == true);
    }

    // SECURITY: Check moderator status from Firebase Custom Claims
    // Admins also have moderator permissions
    function isModerator() {
      return isAuthenticated() &&
             (request.auth.token.moderator == true ||
              isAdmin());
    }

    // SECURITY: Check support role from Firebase Custom Claims
    function isSupport() {
      return isAuthenticated() &&
             (request.auth.token.support == true ||
              isModerator());
    }

    // ============================================
    // USERS COLLECTION
    // ============================================

    match /users/{userId} {
      // Read: Users can read their own profile, admins can read all
      allow read: if isOwner(userId) || isAdmin();

      // Create: Users can create their own profile
      allow create: if isOwner(userId);

      // Update: Users can update their own profile (except role field)
      allow update: if isOwner(userId) &&
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['role']));

      // Admins can update any user
      allow update: if isAdmin();

      // Delete: Only admins
      allow delete: if isAdmin();

      // --- Legacy subcollections (from original rules) ---

      // Weight logs
      match /weightLogs/{logId} {
        allow read, write: if isOwner(userId);
      }

      // Meal logs
      match /mealLogs/{logId} {
        allow read, write: if isOwner(userId);
      }

      // Step logs
      match /stepLogs/{logId} {
        allow read, write: if isOwner(userId);
      }

      // Biometric credentials
      match /biometricCredentials/{credentialId} {
        allow read, write: if isOwner(userId);
      }

      // --- Phase 3 subcollections ---

      // User missions (active)
      match /missions_active/{missionId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }

      // User missions (history)
      match /missions_history/{missionId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId);
        // No updates or deletes on history
      }

      // User coaching data
      match /coaching/{docId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }

      // User nudges queue
      match /nudges_queue/{nudgeId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }

      // User perks (redeemed)
      match /perks_redeemed/{perkId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId);
        // No updates or deletes
      }
    }

    // ============================================
    // GROUPS COLLECTION
    // ============================================

    match /groups/{groupId} {
      // Read: Anyone can read public groups, members can read private groups
      allow read: if resource.data.visibility == 'public' ||
                     (isAuthenticated() && request.auth.uid in resource.data.members);

      // Create: Any authenticated user can create a group
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy == request.auth.uid &&
                      request.resource.data.members.hasAll([request.auth.uid]);

      // Update: Group creator or admins can update
      allow update: if isAuthenticated() &&
                      (resource.data.createdBy == request.auth.uid || isAdmin());

      // Delete: Only creator or admins
      allow delete: if isAuthenticated() &&
                      (resource.data.createdBy == request.auth.uid || isAdmin());

      // Group missions subcollection
      match /missions/{missionId} {
        allow read: if get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
        allow write: if get(/databases/$(database)/documents/groups/$(groupId)).data.createdBy == request.auth.uid || isAdmin();
      }

      // Group members progress
      match /members_progress/{userId} {
        allow read: if get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
        allow write: if isOwner(userId);
      }
    }

    // ============================================
    // MISSIONS & CHALLENGES
    // ============================================

    // Missions catalog (global missions available to users)
    match /missions_catalog/{missionId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Seasonal challenges
    match /seasonal_challenges/{challengeId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // ============================================
    // PERKS (Sponsor Perks)
    // ============================================

    match /perks/{perkId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // ============================================
    // TRUST & SAFETY
    // ============================================

    match /dispute_cases/{caseId} {
      // Read: Case participants or moderators/admins
      allow read: if isAuthenticated() &&
                     (request.auth.uid in resource.data.involvedUserIds ||
                      isModerator());

      // Create: Any authenticated user can create a case
      allow create: if isAuthenticated() &&
                      request.resource.data.reporterId == request.auth.uid;

      // Update: Only moderators/admins
      allow update: if isModerator();

      // Delete: Only admins
      allow delete: if isAdmin();

      // Case actions (audit trail)
      match /actions/{actionId} {
        allow read: if isModerator();
        allow create: if isModerator();
        // No updates or deletes on audit trail
      }
    }

    // ============================================
    // SYSTEM COLLECTIONS
    // ============================================

    // Global biometric fingerprints (server-side only)
    match /biometricFingerprints/{fingerprintId} {
      allow read, write: if false;
    }

    // AI decision logs (admin read-only)
    match /ai_decision_logs/{logId} {
      allow read: if isAdmin();
      allow write: if false;
    }

    // Analytics events
    match /analytics_events/{eventId} {
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;
      allow read: if isAdmin();
    }

    // Admin audit logs (append-only, admin read-only)
    match /admin_audit_logs/{logId} {
      allow read: if isAdmin();
      allow write: if false; // Only server-side writes allowed
    }

    // ============================================
    // RECIPE & COOKING FEATURES
    // ============================================

    // Cooking sessions (kebab-case for backwards compatibility)
    match /cooking-sessions/{sessionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Recipe queue (kebab-case for backwards compatibility)
    match /recipe-queue/{queueId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Recipe completions (for mission tracking)
    match /recipe_completions/{completionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Recipes collection (full recipe library with AI generation)
    match /recipes/{recipeId} {
      // Read: Public access to published recipes (for landing page)
      //       Admins can read all recipes (including drafts)
      // SECURITY NOTE: allow list: if true; is INTENTIONAL for public recipe browsing on landing page
      //                Consider adding rate limiting via Firebase App Check for production
      allow list: if true; // Allow anyone to query recipes collection
      allow get: if resource.data.status == 'published' || isAdmin();

      // Create: Admin-only, with required recipe fields
      allow create: if isAdmin() &&
        // Core recipe fields
        request.resource.data.keys().hasAll(['id', 'name', 'mealType', 'calories', 'macros', 'ingredients', 'prepTime', 'dietaryTags', 'allergens', 'description', 'servingSize', 'status']) &&
        request.resource.data.id is string &&
        request.resource.data.name is string &&
        request.resource.data.mealType in ['breakfast', 'lunch', 'dinner', 'snack'] &&
        request.resource.data.calories is number &&
        request.resource.data.calories > 0 &&
        request.resource.data.macros is map &&
        request.resource.data.ingredients is list &&
        request.resource.data.ingredients.size() > 0 &&
        request.resource.data.prepTime is number &&
        request.resource.data.prepTime > 0 &&
        request.resource.data.dietaryTags is list &&
        request.resource.data.allergens is list &&
        request.resource.data.description is string &&
        request.resource.data.servingSize is number &&
        request.resource.data.servingSize > 0 &&
        // Status validation
        request.resource.data.status in ['draft', 'published', 'archived'] &&
        // Timestamps
        request.resource.data.createdAt is timestamp &&
        request.resource.data.updatedAt is timestamp &&
        // Optional fields validation
        (!('imageUrls' in request.resource.data) || request.resource.data.imageUrls is list) &&
        (!('imageUrls' in request.resource.data) || request.resource.data.imageUrls.size() <= 4);

      // Update: Admin-only, with field validations
      allow update: if isAdmin() &&
        // Cannot change the recipe ID
        request.resource.data.id == resource.data.id &&
        // Status must be valid
        request.resource.data.status in ['draft', 'published', 'archived'] &&
        // Must update the updatedAt timestamp
        request.resource.data.updatedAt is timestamp &&
        // Validate image limits if present
        (!('imageUrls' in request.resource.data) || request.resource.data.imageUrls.size() <= 4);

      // Delete: Admin-only
      allow delete: if isAdmin();
    }

    // ============================================
    // GAMIFICATION & MISSIONS
    // ============================================

    // User missions
    match /user_missions/{missionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;
    }

    // Gamification profiles
    match /gamification/{userId} {
      allow read: if isAuthenticated() && userId == request.auth.uid;
      allow write: if isAuthenticated() && userId == request.auth.uid;
    }

    // XP transactions (read-only for users)
    match /xp_transactions/{transactionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;
    }

    // ============================================
    // NOTIFICATIONS
    // ============================================

    // Notification tokens
    match /notification_tokens/{userId} {
      allow read: if isAuthenticated() && userId == request.auth.uid;
      allow write: if isAuthenticated() && userId == request.auth.uid;
    }

    // Scheduled nudges (notifications)
    match /scheduled_nudges/{nudgeId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() &&
                      resource.data.userId == request.auth.uid;
    }

    // ============================================
    // AI COACH CHAT
    // ============================================

    // Chat messages
    match /chat_messages/{messageId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      // No updates or deletes - chat history is immutable
    }

    // ============================================
    // READINESS ANALYZER (Phase 3 Agent)
    // ============================================

    // Readiness analysis results
    match /readiness_analysis/{analysisId} {
      // Users can read their own analyses
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      // Admins can read all analyses
      allow read: if isAdmin();
      // Only server-side writes (through API with admin SDK)
      allow write: if false;
    }

    // ============================================
    // INACTIVE DETECTION (Phase 3 Agent)
    // ============================================

    // Re-engagement campaigns
    match /reengagement_campaigns/{campaignId} {
      // Users can read their own campaigns
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      // Admins can read all campaigns
      allow read: if isAdmin();
      // Only server-side writes (through API with admin SDK)
      allow write: if false;
    }

    // ============================================
    // MEAL TRACKING
    // ============================================

    // Meals collection
    match /meals/{mealId} {
      // Allow queries and individual document reads for authenticated users querying their own data
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Weight entries
    match /weight_entries/{entryId} {
      // Allow queries and individual document reads for authenticated users querying their own data
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Weight logs (underscore variant for backwards compatibility)
    match /weight_logs/{logId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Weekly missions
    match /weekly_missions/{missionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Cooking sessions (if not already covered above)
    match /cooking_sessions/{sessionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Recipe queue (if not already covered above)
    match /recipe_queue/{queueId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // ============================================
    // SHOPPING & INVENTORY
    // ============================================

    // Shopping items and kitchen inventory
    match /shopping_items/{itemId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Store visits for location tracking
    match /store_visits/{visitId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }

    // ============================================
    // GLOBAL PRODUCT DATABASE
    // ============================================

    // Global product database (aggregated from all user scans)
    match /product_database/{barcode} {
      // Read: Any authenticated user can read products
      allow read: if isAuthenticated();

      // Create/Update: Server-side only (via API with Admin SDK)
      allow write: if false;

      // Scan events subcollection (for analytics)
      match /scans/{scanId} {
        allow read: if isAdmin();
        allow write: if false;
      }

      // Edit history subcollection (for audit trail)
      match /edit_history/{editId} {
        allow read: if isAdmin();
        allow write: if false;
      }
    }

    // ============================================
    // DEFAULT DENY
    // ============================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}