rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // ============================================

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // SECURITY: Super admin check using hardcoded UIDs (for bootstrapping)
    // Once custom claims are set, prefer using isAdmin() which checks token claims
    function isSuperAdmin() {
      return isAuthenticated() &&
             (request.auth.uid == 'Y8wSTgymg3YXWU94iJVjzoGxsMI2' ||
              request.auth.token.email == 'perriceconsulting@gmail.com' ||
              request.auth.token.email == 'weightlossprojectionlab@gmail.com');
    }

    // SECURITY: Check admin status from Firebase Custom Claims (fast, no Firestore read)
    // Falls back to super admin check for bootstrapping
    function isAdmin() {
      return isAuthenticated() &&
             (isSuperAdmin() ||
              request.auth.token.admin == true);
    }

    // SECURITY: Check moderator status from Firebase Custom Claims
    // Admins also have moderator permissions
    function isModerator() {
      return isAuthenticated() &&
             (request.auth.token.moderator == true ||
              isAdmin());
    }

    // SECURITY: Check support role from Firebase Custom Claims
    function isSupport() {
      return isAuthenticated() &&
             (request.auth.token.support == true ||
              isModerator());
    }

    // ============================================
    // PLAN TIER & BACKDATE VALIDATION
    // ============================================

    // Get user's plan tier (defaults to 'free' if not found)
    function getUserPlanTier(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc != null && 'planTier' in userDoc.data
        ? userDoc.data.planTier
        : 'free';
    }

    // Get max backdate days allowed for plan tier
    function getBackdateLimit(tier) {
      return tier == 'enterprise' ? 365 :
             tier == 'premium' ? 90 :
             7; // free tier default
    }

    // Validate backdate is within plan tier limits
    // recordedAtMillis: Timestamp in milliseconds (from ISO string converted to timestamp)
    // loggedAtMillis: Current request timestamp in milliseconds
    // userTier: User's plan tier ('free', 'premium', 'enterprise')
    function isValidBackdate(recordedAtMillis, loggedAtMillis, userTier) {
      let daysDiff = duration.abs(duration.time(loggedAtMillis, 0) - duration.time(recordedAtMillis, 0)).hours() / 24;
      let maxDays = getBackdateLimit(userTier);
      return daysDiff <= maxDays;
    }

    // ============================================
    // USERS COLLECTION
    // ============================================

    match /users/{userId} {
      // Read: Users can read their own profile, admins can read all
      allow read: if isOwner(userId) || isAdmin();

      // Allow admins to query the users collection (for admin stats)
      allow list: if isAdmin();

      // Create: Users can create their own profile
      allow create: if isOwner(userId);

      // Update: Users can update their own profile (except role field)
      allow update: if isOwner(userId) &&
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['role']));

      // Admins can update any user
      allow update: if isAdmin();

      // Delete: Only admins
      allow delete: if isAdmin();

      // ============================================
      // USER SETTINGS SUBCOLLECTION
      // ============================================
      match /settings/{settingId} {
        // Users can read/write their own settings
        allow read, write: if isOwner(userId);
      }

      // ============================================
      // MEDICAL RECORDS - PATIENT PROFILES
      // ============================================

      // Patient profiles
      match /patients/{patientId} {
        // Read: Owner can read their patients
        allow read: if isOwner(userId);

        // Create: Owner can create patients
        allow create: if isOwner(userId) &&
                        request.resource.data.userId == userId;

        // Update: Owner can update their patients
        allow update: if isOwner(userId) &&
                        resource.data.userId == userId;

        // Delete: Owner can delete their patients
        allow delete: if isOwner(userId) &&
                        resource.data.userId == userId;

        // Vital signs subcollection
        match /vitals/{vitalId} {
          allow read: if isOwner(userId);

          // Create: Owner can create vitals with date validation and plan tier enforcement
          allow create: if isOwner(userId) &&
                          request.resource.data.patientId == patientId &&
                          // Required fields must exist
                          request.resource.data.recordedAt is string &&
                          request.resource.data.loggedAt is string &&
                          request.resource.data.loggedBy is string &&
                          // recordedAt cannot be in the future
                          timestamp(request.resource.data.recordedAt) <= request.time &&
                          // loggedAt should be current timestamp (within reasonable tolerance)
                          timestamp(request.resource.data.loggedAt) <= request.time &&
                          // Enforce plan tier backdate limits
                          isValidBackdate(
                            timestamp(request.resource.data.recordedAt).toMillis(),
                            timestamp(request.resource.data.loggedAt).toMillis(),
                            getUserPlanTier(userId)
                          );

          allow update: if isOwner(userId);
          allow delete: if isOwner(userId);
        }

        // Weight logs subcollection (hyphenated naming)
        match /weight-logs/{logId} {
          allow read: if isOwner(userId);
          allow create: if isOwner(userId) &&
                          request.resource.data.patientId == patientId &&
                          request.resource.data.userId == userId;
          allow update: if isOwner(userId);
          allow delete: if isOwner(userId);
        }

        // Meal logs subcollection (hyphenated naming)
        match /meal-logs/{logId} {
          allow read: if isOwner(userId);
          allow create: if isOwner(userId) &&
                          request.resource.data.patientId == patientId &&
                          request.resource.data.userId == userId;
          allow update: if isOwner(userId);
          allow delete: if isOwner(userId);
        }

        // Step logs subcollection (hyphenated naming)
        match /step-logs/{logId} {
          allow read: if isOwner(userId);
          allow create: if isOwner(userId) &&
                          request.resource.data.patientId == patientId &&
                          request.resource.data.userId == userId;
          allow update: if isOwner(userId);
          allow delete: if isOwner(userId);
        }

        // Medications subcollection
        match /medications/{medicationId} {
          // Read: Owner or admin
          allow read: if isOwner(userId) || isAdmin();

          // Create: Owner with validation, or admin
          allow create: if (isOwner(userId) &&
                           request.resource.data.patientId == patientId &&
                           request.resource.data.userId == userId) ||
                          isAdmin();

          // Update: Owner or admin
          allow update: if isOwner(userId) || isAdmin();

          // Delete: Owner or admin
          allow delete: if isOwner(userId) || isAdmin();

          // Medication audit logs (immutable audit trail)
          match /auditLogs/{logId} {
            // Read: Owner or admin can read audit logs
            allow read: if isOwner(userId) || isAdmin();

            // Create: Server-side only (via API with Admin SDK)
            // Prevents client-side tampering
            allow create: if false;

            // Update/Delete: Never allowed (immutable audit trail)
            allow update, delete: if false;
          }
        }

        // Deleted medications archive (audit trail - read-only for users)
        match /deletedMedications/{medicationId} {
          // Read: Owner or admin (for audit purposes)
          allow read: if isOwner(userId) || isAdmin();

          // Write: Only backend can write to this collection
          allow write: if false;
        }

        // Documents subcollection (insurance cards, medical records, etc.)
        match /documents/{documentId} {
          allow read: if isOwner(userId);
          allow create: if isOwner(userId) &&
                          request.resource.data.patientId == patientId &&
                          request.resource.data.userId == userId;
          allow update: if isOwner(userId);
          allow delete: if isOwner(userId);
        }

        // Helper function to check if user is a family member with access
        function isFamilyMemberWithAccess() {
          return exists(/databases/$(database)/documents/users/$(userId)/familyMembers/$(request.auth.uid));
        }

        // Helper function to check if family member has specific permission
        function hasFamilyPermission(permission) {
          return isFamilyMemberWithAccess() &&
                 get(/databases/$(database)/documents/users/$(userId)/familyMembers/$(request.auth.uid)).data.permissions[permission] == true;
        }

        // ============================================
        // UNIFIED AUDIT TRAIL (CROSS-ENTITY)
        // ============================================

        // Audit logs for all entities (medications, documents, vitals, etc.)
        // Collection group path examples:
        // - users/{userId}/patients/{patientId}/medications/{medicationId}/auditLogs/{logId}
        // - users/{userId}/patients/{patientId}/documents/{documentId}/auditLogs/{logId}
        // - users/{userId}/patients/{patientId}/vitals/{vitalId}/auditLogs/{logId}
        match /{path=**}/auditLogs/{logId} {
          // Read: Owner or family member with access can read audit logs
          allow read: if isOwner(userId) ||
                        (isFamilyMemberWithAccess() &&
                         hasFamilyPermission('viewMedicalRecords'));

          // Create: Server-side only (via API with Admin SDK)
          // This prevents client-side tampering of audit trails
          allow create: if false;

          // Update/Delete: Never allowed (immutable audit trail)
          // Audit logs are write-once, read-many for compliance
          allow update, delete: if false;
        }

        // Healthcare providers for this patient
        match /healthcareProviders/{providerId} {
          // Read: Patient owner OR family member with viewProviders permission
          allow read: if isOwner(userId) || hasFamilyPermission('viewProviders');

          // Create: Patient owner OR family member with manageProviders permission
          // Validate: patientId must match, addedBy must be auth.uid
          allow create: if (isOwner(userId) || hasFamilyPermission('manageProviders')) &&
                          request.resource.data.patientId == patientId &&
                          request.resource.data.addedBy == request.auth.uid;

          // Update: Patient owner OR family member with manageProviders permission
          allow update: if isOwner(userId) || hasFamilyPermission('manageProviders');

          // Delete: Patient owner OR family member with manageProviders permission
          allow delete: if isOwner(userId) || hasFamilyPermission('manageProviders');
        }

        // Communications with healthcare providers
        match /providerCommunications/{communicationId} {
          // Read: Patient owner OR family member with viewProviders permission
          allow read: if isOwner(userId) || hasFamilyPermission('viewProviders');

          // Create: Patient owner OR family member with manageProviders permission
          // Validate: patientId must match, sentBy must be auth.uid
          allow create: if (isOwner(userId) || hasFamilyPermission('manageProviders')) &&
                          request.resource.data.patientId == patientId &&
                          request.resource.data.sentBy == request.auth.uid;

          // Update: Not allowed (communications are immutable after creation)
          allow update: if false;

          // Delete: Not allowed (keep audit trail)
          allow delete: if false;
        }

        // Generated health reports for this patient
        match /healthReports/{reportId} {
          // Read: Patient owner OR family member with viewMedicalRecords permission
          allow read: if isOwner(userId) || hasFamilyPermission('viewMedicalRecords');

          // Create: Patient owner OR family member with viewMedicalRecords permission
          // Validate: patientId must match, generatedBy must be auth.uid
          allow create: if (isOwner(userId) || hasFamilyPermission('viewMedicalRecords')) &&
                          request.resource.data.patientId == patientId &&
                          request.resource.data.generatedBy == request.auth.uid;

          // Update: Patient owner OR family member with viewMedicalRecords permission (for regeneration)
          // Validate: patientId cannot be changed, generatedBy must be auth.uid
          allow update: if (isOwner(userId) || hasFamilyPermission('viewMedicalRecords')) &&
                          request.resource.data.patientId == resource.data.patientId &&
                          request.resource.data.generatedBy == request.auth.uid;

          // Delete: Patient owner only (only owner can delete reports)
          allow delete: if isOwner(userId);
        }
      }

      // ============================================
      // MEDICAL RECORDS - FAMILY COLLABORATION
      // ============================================

      // Family members who have access to user's patients
      match /familyMembers/{memberId} {
        // Read: Owner can read their family members list
        allow read: if isOwner(userId);

        // Create: Server-side only (via invitation acceptance)
        allow create: if false;

        // Update: Owner can update permissions
        allow update: if isOwner(userId) &&
                        resource.data.userId == request.resource.data.userId;

        // Delete: Owner can remove family members
        allow delete: if isOwner(userId);
      }

      // ============================================
      // MEDICAL RECORDS - APPOINTMENTS
      // ============================================

      // Appointments
      match /appointments/{appointmentId} {
        // Read: Owner can read their appointments
        allow read: if isOwner(userId);

        // Create: Owner can create appointments
        allow create: if isOwner(userId);

        // Update: Owner can update their appointments
        allow update: if isOwner(userId);

        // Delete: Owner can delete their appointments
        allow delete: if isOwner(userId);
      }

      // --- Legacy subcollections (from original rules) ---

      // Weight logs
      match /weightLogs/{logId} {
        allow read, write: if isOwner(userId);
      }

      // Meal logs
      match /mealLogs/{logId} {
        allow read, write: if isOwner(userId);
      }

      // Step logs
      match /stepLogs/{logId} {
        allow read, write: if isOwner(userId);
      }

      // Biometric credentials
      match /biometricCredentials/{credentialId} {
        allow read, write: if isOwner(userId);
      }

      // --- Phase 3 subcollections ---

      // User missions (active)
      match /missions_active/{missionId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }

      // User missions (history)
      match /missions_history/{missionId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId);
        // No updates or deletes on history
      }

      // User coaching data
      match /coaching/{docId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }

      // User nudges queue
      match /nudges_queue/{nudgeId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }

      // User perks (redeemed)
      match /perks_redeemed/{perkId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId);
        // No updates or deletes
      }

      // ============================================
      // SHOPPING - STORES & PRICE HISTORY
      // ============================================

      // User's favorite stores
      match /stores/{storeId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) &&
                        request.resource.data.userId == userId;
        allow update: if isOwner(userId) &&
                        resource.data.userId == userId;
        allow delete: if isOwner(userId);
      }

      // Price history tracking
      match /price_history/{priceId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) &&
                        request.resource.data.userId == userId;
        // Price history is append-only (no updates or deletes)
      }

      // ============================================
      // MEMBER SHOPPING LISTS (FAMILY PLANS)
      // ============================================

      // Member shopping lists - Per-member shopping needs within household
      match /member_shopping_lists/{memberId} {
        // Helper to check if requester can access this member's list
        function canAccessMemberList() {
          return isOwner(userId) || // Account owner can access all
                 request.auth.uid == memberId; // Member can access their own list
        }

        // Read: Account owner or the member themselves
        allow read: if canAccessMemberList();

        // Items subcollection
        match /items/{itemId} {
          // Read: Account owner or the member themselves
          allow read: if canAccessMemberList();

          // Create: Account owner or the member themselves
          allow create: if canAccessMemberList() &&
                          request.resource.data.memberId == memberId &&
                          request.resource.data.householdId == userId;

          // Update: Account owner or the member themselves
          allow update: if canAccessMemberList() &&
                          resource.data.memberId == memberId;

          // Delete: Account owner or the member themselves
          allow delete: if canAccessMemberList();
        }
      }
    }

    // ============================================
    // GROUPS COLLECTION
    // ============================================

    match /groups/{groupId} {
      // Read: Anyone can read public groups, members can read private groups
      allow read: if resource.data.visibility == 'public' ||
                     (isAuthenticated() && request.auth.uid in resource.data.members);

      // Create: Any authenticated user can create a group
      allow create: if isAuthenticated() &&
                      request.resource.data.createdBy == request.auth.uid &&
                      request.resource.data.members.hasAll([request.auth.uid]);

      // Update: Group creator or admins can update
      allow update: if isAuthenticated() &&
                      (resource.data.createdBy == request.auth.uid || isAdmin());

      // Delete: Only creator or admins
      allow delete: if isAuthenticated() &&
                      (resource.data.createdBy == request.auth.uid || isAdmin());

      // Group missions subcollection
      match /missions/{missionId} {
        allow read: if get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
        allow write: if get(/databases/$(database)/documents/groups/$(groupId)).data.createdBy == request.auth.uid || isAdmin();
      }

      // Group members progress
      match /members_progress/{userId} {
        allow read: if get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
        allow write: if isOwner(userId);
      }
    }

    // ============================================
    // MISSIONS & CHALLENGES
    // ============================================

    // Missions catalog (global missions available to users)
    match /missions_catalog/{missionId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Seasonal challenges
    match /seasonal_challenges/{challengeId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // ============================================
    // PERKS (Sponsor Perks)
    // ============================================

    match /perks/{perkId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // ============================================
    // TRUST & SAFETY
    // ============================================

    match /dispute_cases/{caseId} {
      // Read: Case participants or moderators/admins
      allow read: if isAuthenticated() &&
                     (request.auth.uid in resource.data.involvedUserIds ||
                      isModerator());

      // Allow moderators/admins to query the collection (for admin stats)
      allow list: if isModerator();

      // Create: Any authenticated user can create a case
      allow create: if isAuthenticated() &&
                      request.resource.data.reporterId == request.auth.uid;

      // Update: Only moderators/admins
      allow update: if isModerator();

      // Delete: Only admins
      allow delete: if isAdmin();

      // Case actions (audit trail)
      match /actions/{actionId} {
        allow read: if isModerator();
        allow create: if isModerator();
        // No updates or deletes on audit trail
      }
    }

    // ============================================
    // SYSTEM COLLECTIONS
    // ============================================

    // Global biometric fingerprints (server-side only)
    match /biometricFingerprints/{fingerprintId} {
      allow read, write: if false;
    }

    // AI decision logs (admin read-only)
    match /ai_decision_logs/{logId} {
      allow read: if isAdmin();
      allow list: if isAdmin(); // Allow admins to query the collection
      allow write: if false;
    }

    // Analytics events
    match /analytics_events/{eventId} {
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;
      allow read: if isAdmin();
    }

    // Admin audit logs (append-only, admin read-only)
    match /admin_audit_logs/{logId} {
      allow read: if isAdmin();
      allow write: if false; // Only server-side writes allowed
    }

    // ============================================
    // RECIPE & COOKING FEATURES
    // ============================================

    // Cooking sessions (kebab-case for backwards compatibility)
    match /cooking-sessions/{sessionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Recipe queue (kebab-case for backwards compatibility)
    match /recipe-queue/{queueId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Recipe completions (for mission tracking)
    match /recipe_completions/{completionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Recipes collection (full recipe library with AI generation)
    match /recipes/{recipeId} {
      // Individual recipe reads: public for published recipes
      allow get: if resource.data.status == 'published' || isAdmin();

      // List queries: require authentication + pagination
      // TODO: Enable Firebase App Check in Firebase Console for additional protection
      // NOTE: Firebase App Check should be enabled to protect against automated abuse
      //       Setup: Firebase Console > Build > App Check > Register your app
      allow list: if isAuthenticated()
                  && request.query.limit <= 50;

      // Create: Admin-only, with required recipe fields
      allow create: if isAdmin() &&
        // Core recipe fields
        request.resource.data.keys().hasAll(['id', 'name', 'mealType', 'calories', 'macros', 'ingredients', 'prepTime', 'dietaryTags', 'allergens', 'description', 'servingSize', 'status']) &&
        request.resource.data.id is string &&
        request.resource.data.name is string &&
        request.resource.data.mealType in ['breakfast', 'lunch', 'dinner', 'snack'] &&
        request.resource.data.calories is number &&
        request.resource.data.calories > 0 &&
        request.resource.data.macros is map &&
        request.resource.data.ingredients is list &&
        request.resource.data.ingredients.size() > 0 &&
        request.resource.data.prepTime is number &&
        request.resource.data.prepTime > 0 &&
        request.resource.data.dietaryTags is list &&
        request.resource.data.allergens is list &&
        request.resource.data.description is string &&
        request.resource.data.servingSize is number &&
        request.resource.data.servingSize > 0 &&
        // Status validation
        request.resource.data.status in ['draft', 'published', 'archived'] &&
        // Timestamps
        request.resource.data.createdAt is timestamp &&
        request.resource.data.updatedAt is timestamp &&
        // Optional fields validation
        (!('imageUrls' in request.resource.data) || request.resource.data.imageUrls is list) &&
        (!('imageUrls' in request.resource.data) || request.resource.data.imageUrls.size() <= 4);

      // Update: Admin-only, with field validations
      allow update: if isAdmin() &&
        // Cannot change the recipe ID
        request.resource.data.id == resource.data.id &&
        // Status must be valid
        request.resource.data.status in ['draft', 'published', 'archived'] &&
        // Must update the updatedAt timestamp
        request.resource.data.updatedAt is timestamp &&
        // Validate image limits if present
        (!('imageUrls' in request.resource.data) || request.resource.data.imageUrls.size() <= 4);

      // Delete: Admin-only
      allow delete: if isAdmin();
    }

    // Public recipes (user-submitted recipes for moderation)
    match /publicRecipes/{recipeId} {
      // Read: Admins and moderators only
      allow read: if isModerator();

      // List queries: Admins and moderators only (for moderation queue)
      allow list: if isModerator();

      // Create: Authenticated users can submit recipes
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;

      // Update: Moderators can update moderation status
      allow update: if isModerator();

      // Delete: Admin-only
      allow delete: if isAdmin();
    }

    // ============================================
    // GAMIFICATION & MISSIONS
    // ============================================

    // User missions
    match /user_missions/{missionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;
    }

    // Gamification profiles
    match /gamification/{userId} {
      allow read: if isAuthenticated() && userId == request.auth.uid;
      allow write: if isAuthenticated() && userId == request.auth.uid;
    }

    // XP transactions (read-only for users)
    match /xp_transactions/{transactionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;
    }

    // ============================================
    // NOTIFICATIONS
    // ============================================

    // Notification tokens
    match /notification_tokens/{userId} {
      allow read: if isAuthenticated() && userId == request.auth.uid;
      allow write: if isAuthenticated() && userId == request.auth.uid;
    }

    // Scheduled nudges (notifications)
    match /scheduled_nudges/{nudgeId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() &&
                      resource.data.userId == request.auth.uid;
    }

    // ============================================
    // AI COACH CHAT
    // ============================================

    // Chat messages
    match /chat_messages/{messageId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      // No updates or deletes - chat history is immutable
    }

    // ============================================
    // READINESS ANALYZER (Phase 3 Agent)
    // ============================================

    // Readiness analysis results
    match /readiness_analysis/{analysisId} {
      // Users can read their own analyses
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      // Admins can read all analyses
      allow read: if isAdmin();
      // Only server-side writes (through API with admin SDK)
      allow write: if false;
    }

    // ============================================
    // INACTIVE DETECTION (Phase 3 Agent)
    // ============================================

    // Re-engagement campaigns
    match /reengagement_campaigns/{campaignId} {
      // Users can read their own campaigns
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      // Admins can read all campaigns
      allow read: if isAdmin();
      // Only server-side writes (through API with admin SDK)
      allow write: if false;
    }

    // ============================================
    // MEAL TRACKING
    // ============================================

    // Meals collection
    match /meals/{mealId} {
      // Allow queries and individual document reads for authenticated users querying their own data
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Weight entries
    match /weight_entries/{entryId} {
      // Allow queries and individual document reads for authenticated users querying their own data
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Weight logs (underscore variant for backwards compatibility)
    match /weight_logs/{logId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Weekly missions
    match /weekly_missions/{missionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Cooking sessions (if not already covered above)
    match /cooking_sessions/{sessionId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Recipe queue (if not already covered above)
    match /recipe_queue/{queueId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // ============================================
    // SHOPPING & INVENTORY
    // ============================================

    // Helper function to check if user is in the household (account owner or family member)
    function isHouseholdMember(householdId) {
      return isAuthenticated() && (
        // User is the account owner
        request.auth.uid == householdId ||
        // User is a family member with access
        exists(/databases/$(database)/documents/users/$(householdId)/familyMembers/$(request.auth.uid))
      );
    }

    // ============================================
    // SHOPPING SESSIONS (SESSION TRACKING)
    // ============================================

    // Shopping sessions - Track active shopping to prevent bulk list operations
    match /shopping_sessions/{sessionId} {
      // Anyone can read sessions (to check for active shopping before bulk operations)
      allow read: if isAuthenticated();

      // Users can create their own sessions
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.householdId != null;

      // Users can update their own sessions (heartbeat, item count, status)
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;

      // Users can delete their own sessions OR household owner can force-end any
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.householdId == request.auth.uid
      );
    }

    // ============================================
    // BULK OPERATION AUDIT LOGS
    // ============================================

    // Audit logs for bulk operations (clear shopping list, batch discard)
    match /bulk_operation_audit_logs/{logId} {
      // Users can read their own audit logs
      allow read: if isAuthenticated() &&
                     resource.data.performedBy == request.auth.uid;

      // Admins can read all audit logs
      allow read: if isAdmin();

      // Users can create audit logs (system-generated during bulk operations)
      allow create: if isAuthenticated() &&
                      request.resource.data.performedBy == request.auth.uid;

      // Audit logs are immutable - no updates or deletes
      allow update, delete: if false;
    }

    // Shopping items and kitchen inventory (household shared)
    match /shopping_items/{itemId} {
      // Read: Owner or family members can read
      allow read: if isAuthenticated() &&
                     (resource == null ||
                      resource.data.userId == request.auth.uid ||
                      (resource.data.householdId != null && isHouseholdMember(resource.data.householdId)));

      // Create: Owner or family members can create
      allow create: if isAuthenticated() &&
                      (request.resource.data.userId == request.auth.uid ||
                       (request.resource.data.householdId != null && isHouseholdMember(request.resource.data.householdId)));

      // Update: Owner or family members can update
      allow update: if isAuthenticated() &&
                      (resource.data.userId == request.auth.uid ||
                       (resource.data.householdId != null && isHouseholdMember(resource.data.householdId)));

      // Delete: Owner or family members can delete
      allow delete: if isAuthenticated() &&
                      (resource.data.userId == request.auth.uid ||
                       (resource.data.householdId != null && isHouseholdMember(resource.data.householdId)));
    }

    // Inventory actions - Audit trail for inventory changes (discard, consume, etc.)
    match /inventory_actions/{actionId} {
      // Read: Any authenticated user can read their own actions
      allow read: if isAuthenticated();

      // Create: Any authenticated user can create actions
      allow create: if isAuthenticated() &&
                      request.resource.data.performedBy == request.auth.uid;

      // Update/Delete: Not allowed (immutable audit trail)
      allow update, delete: if false;
    }

    // Store visits for location tracking
    match /store_visits/{visitId} {
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }

    // ============================================
    // GLOBAL PRODUCT DATABASE
    // ============================================

    // Global product database (aggregated from all user scans)
    match /product_database/{barcode} {
      // Read: Any authenticated user can read products
      allow read: if isAuthenticated();

      // Create/Update: Server-side only (via API with Admin SDK)
      allow write: if false;

      // Scan events subcollection (for analytics)
      match /scans/{scanId} {
        allow read: if isAdmin();
        allow write: if false;
      }

      // Edit history subcollection (for audit trail)
      match /edit_history/{editId} {
        allow read: if isAdmin();
        allow write: if false;
      }
    }

    // ============================================
    // MEDICAL RECORDS - FAMILY INVITATIONS
    // ============================================

    // Family invitations (global collection)
    match /familyInvitations/{invitationId} {
      // Read: Inviter can read invitations they sent
      allow read: if isAuthenticated() &&
                     resource.data.invitedByUserId == request.auth.uid;

      // Read: Recipient can read invitations sent to their email
      allow read: if isAuthenticated() &&
                     resource.data.recipientEmail == request.auth.token.email;

      // Create: Any authenticated user can create invitations
      allow create: if isAuthenticated() &&
                      request.resource.data.invitedByUserId == request.auth.uid;

      // Update: Server-side only (via accept/decline/revoke API)
      allow update: if false;

      // Delete: Only admins
      allow delete: if isAdmin();
    }

    // ============================================
    // HOUSEHOLDS (MULTI-LOCATION RESIDENCE MANAGEMENT)
    // ============================================

    // Helper: Check if user has access to household
    function canAccessHousehold(householdData) {
      return isAuthenticated() &&
             (householdData.primaryCaregiverId == request.auth.uid ||
              (householdData.additionalCaregiverIds != null &&
               householdData.additionalCaregiverIds.hasAny([request.auth.uid])));
    }

    // Households collection
    match /households/{householdId} {
      // Read: Primary or additional caregiver can read
      allow read: if isAuthenticated() &&
                     canAccessHousehold(resource.data);

      // Create: Any authenticated user can create households
      allow create: if isAuthenticated() &&
                      request.resource.data.primaryCaregiverId == request.auth.uid &&
                      request.resource.data.createdBy == request.auth.uid;

      // Update: Only primary caregiver (not additional caregivers)
      allow update: if isAuthenticated() &&
                      resource.data.primaryCaregiverId == request.auth.uid;

      // Delete: Only primary caregiver
      allow delete: if isAuthenticated() &&
                      resource.data.primaryCaregiverId == request.auth.uid;
    }

    // ============================================
    // HEALTHCARE PROVIDERS (MULTI-MEMBER ASSIGNMENT)
    // ============================================

    // Helper function to check if user owns any of the provider's assigned patients
    function ownsAnyProviderPatient(providerData) {
      // Get the first patient ID from patientIds array
      let firstPatientId = providerData.patientIds[0];
      // Check if that patient belongs to the current user
      return exists(/databases/$(database)/documents/patients/$(firstPatientId)) &&
             get(/databases/$(database)/documents/patients/$(firstPatientId)).data.userId == request.auth.uid;
    }

    // Healthcare providers collection (top-level)
    match /healthcareProviders/{providerId} {
      // Read: Provider belongs to user (via userId field OR user owns any assigned patient)
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid ||
                      ownsAnyProviderPatient(resource.data));

      // Create: Any authenticated user can create providers for their patients
      // Must provide userId and valid patientIds array
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.patientIds is list &&
                      request.resource.data.patientIds.size() > 0;

      // Update: Owner can update (user who created the provider)
      allow update: if isAuthenticated() &&
                      resource.data.userId == request.auth.uid;

      // Delete: Owner can delete
      allow delete: if isAuthenticated() &&
                      resource.data.userId == request.auth.uid;
    }

    // Provider communications log
    match /providerCommunications/{commId} {
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;

      allow update: if isAuthenticated() &&
                      resource.data.userId == request.auth.uid;
    }

    // Health reports collection (top-level for cross-patient access)
    match /healthReports/{reportId} {
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;

      allow update: if isAuthenticated() &&
                      resource.data.userId == request.auth.uid;

      allow delete: if isAuthenticated() &&
                      resource.data.userId == request.auth.uid;
    }

    // ============================================
    // NOTIFICATIONS COLLECTION
    // ============================================

    // User notifications (root collection)
    match /notifications/{notificationId} {
      // Read: Users can read their own notifications
      allow read: if isAuthenticated() &&
                     (resource == null || resource.data.userId == request.auth.uid);

      // Create: Server-side only (via API with Admin SDK)
      allow create: if false;

      // Update: Users can mark their own notifications as read
      allow update: if isAuthenticated() &&
                      resource.data.userId == request.auth.uid &&
                      request.resource.data.userId == resource.data.userId &&
                      // Only allow updating the 'read' field
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);

      // Delete: Server-side only
      allow delete: if false;
    }

    // ============================================
    // DEFAULT DENY
    // ============================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}